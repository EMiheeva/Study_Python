#https://e-maxx.ru/algo/kuhn_matching
n = 6
k = 9
# 1 -> 3, но 3 под номером 2 во второй доле (k=9)
# 1 -> 13, но 13 под номером 4 во второй доле (k=9)
graph = [[2, 4, 5, 7], 
    [0, 6, 8, 3, 7, 1, 2, 5], 
    [3, 8, 7, 1, 6, 4], 
    [8, 7], 
    [1, 2, 4, 5], 
    [3, 6, 5, 2, 7, 4]]
mt = [-1] * k #содержит в себе информацию о текущем паросочетании. 
            #Для удобства программирования, информация эта содержится только для вершин второй доли: 
            #mt[i] — это номер вершины первой доли, связанной ребром с вершиной i второй доли 
            #(или -1, если никакого ребра паросочетания из i не выходит).
used = [False] * n #Второй массив — used — обычный массив "посещённостей" вершин в обходе в глубину 
                   #(он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).
mas1 = [1, 2, 14, 5, 7, 8]
mas2 = [6, 15, 3, 4, 13, 12, 11, 10, 9]

def dfs_try_kuhn(v):
    if used[v]:
        return False
    used[v] = True
    for i in range(len(graph[v])):
        to = graph[v][i]
        if mt[to] == -1 or dfs_try_kuhn(mt[to]):
            mt[to] = v
            return True #Она возвращает true, если ей удалось найти увеличивающую цепь из вершины v, 
                        #при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.
    return False

for v in range(n):
    used = [False] * n
    dfs_try_kuhn(v)

count = 0
print("Ребра в максимальном паросочетании: ")
for i in range(k):
    if mt[i] != -1:
        print(mas1[mt[i]], mas2[i])
        count += 1
print(f"Максимальное паросочетание равно: {count}")
